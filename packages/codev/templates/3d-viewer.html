<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{FILE}} - 3D Viewer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000000;
      color: #e0e0e0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #header {
      background: #16213e;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #0f3460;
      flex-shrink: 0;
    }

    #filename {
      font-size: 14px;
      color: #94a3b8;
    }

    #info {
      font-size: 12px;
      color: #64748b;
    }

    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .control-group {
      display: flex;
      gap: 4px;
      padding: 0 8px;
      border-right: 1px solid #0f3460;
    }

    .control-group:last-child {
      border-right: none;
    }

    .control-label {
      font-size: 10px;
      color: #64748b;
      margin-right: 4px;
      align-self: center;
    }

    button {
      background: #0f3460;
      color: #e0e0e0;
      border: 1px solid #1e4976;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.2s;
      min-width: 28px;
    }

    button:hover {
      background: #1e4976;
    }

    button.active {
      background: #2563eb;
      border-color: #3b82f6;
    }

    button.view-btn {
      font-family: monospace;
      font-weight: bold;
    }

    /* Color view buttons to match axes: X=red, Y=green, Z=blue */
    button.view-btn.axis-x {
      color: #ef4444;
    }

    button.view-btn.axis-y {
      color: #22c55e;
    }

    button.view-btn.axis-z {
      color: #3b82f6;
    }

    #canvas-container {
      flex: 1;
      position: relative;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #94a3b8;
    }

    #loading .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #0f3460;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #error {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #ef4444;
      display: none;
    }

    .hidden {
      display: none !important;
    }

    /* Axes legend */
    #axes-legend {
      position: absolute;
      bottom: 16px;
      left: 16px;
      background: rgba(22, 33, 62, 0.9);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-family: monospace;
    }

    #axes-legend div {
      margin: 2px 0;
    }

    .axis-x { color: #ef4444; }
    .axis-y { color: #22c55e; }
    .axis-z { color: #3b82f6; }
  </style>
</head>
<body>
  <div id="header">
    <div>
      <span id="filename">{{FILE}}</span>
      <span id="info"></span>
    </div>
    <div id="controls">
      <div class="control-group">
        <span class="control-label">View:</span>
        <button id="viewRight" class="view-btn axis-x" title="Right (from +X)">Right</button>
        <button id="viewLeft" class="view-btn axis-x" title="Left (from -X)">Left</button>
        <button id="viewFront" class="view-btn axis-y" title="Front (from -Y)">Front</button>
        <button id="viewBack" class="view-btn axis-y" title="Back (from +Y)">Back</button>
        <button id="viewTop" class="view-btn axis-z" title="Top (looking down Z)">Top</button>
        <button id="viewBottom" class="view-btn axis-z" title="Bottom (looking up)">Bot</button>
      </div>
      <div class="control-group">
        <button id="viewIso" title="Toggle perspective/orthographic">Persp</button>
        <button id="resetBtn" title="Fit model to view">Fit</button>
      </div>
      <div class="control-group">
        <button id="wireframeBtn" title="Toggle wireframe mode">Wire</button>
        <button id="axesBtn" class="active" title="Toggle axes">Axes</button>
        <button id="gridBtn" class="active" title="Toggle grid">Grid</button>
      </div>
    </div>
  </div>

  <div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="loading">
      <div class="spinner"></div>
      <div id="loading-text">Loading 3D model...</div>
    </div>
    <div id="error">
      <div style="font-size: 48px; margin-bottom: 12px;">&#9888;</div>
      <div id="error-message">Failed to load 3D model</div>
    </div>
    <div id="axes-legend">
      <div class="axis-x">X → Right</div>
      <div class="axis-y">Y → Front</div>
      <div class="axis-z">Z → Up</div>
    </div>
  </div>

  <!-- Three.js ES Modules via import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';
    import { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

    // Configuration (injected by server with proper escaping)
    const FILE_PATH = {{FILE_PATH_JSON}};  // JSON-encoded by server
    const FILE_NAME = '{{FILE}}';
    const FORMAT = '{{FORMAT}}';  // 'stl' or '3mf'

    // Three.js setup
    let scene, camera, orthoCamera, perspCamera, renderer, controls;
    let model = null;  // Can be mesh (STL) or group (3MF)
    let wireframeMesh = null;  // Wireframe overlay mesh
    let axesHelper, gridHelper;
    let viewMode = 'solid';  // 'solid', 'wireframe', or 'both'
    let showAxes = true;
    let showGrid = true;
    let isOrthographic = false;
    let modelCenter = new THREE.Vector3();
    let cameraDistance = 100;

    // DOM elements
    const canvas = document.getElementById('canvas');
    const container = document.getElementById('canvas-container');
    const loading = document.getElementById('loading');
    const loadingText = document.getElementById('loading-text');
    const error = document.getElementById('error');
    const errorMessage = document.getElementById('error-message');
    const info = document.getElementById('info');

    // Buttons
    const resetBtn = document.getElementById('resetBtn');
    const wireframeBtn = document.getElementById('wireframeBtn');
    const axesBtn = document.getElementById('axesBtn');
    const gridBtn = document.getElementById('gridBtn');
    const viewTop = document.getElementById('viewTop');
    const viewBottom = document.getElementById('viewBottom');
    const viewFront = document.getElementById('viewFront');
    const viewBack = document.getElementById('viewBack');
    const viewRight = document.getElementById('viewRight');
    const viewLeft = document.getElementById('viewLeft');
    const viewIso = document.getElementById('viewIso');

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Cameras (Z-up coordinate system)
      const aspect = container.clientWidth / container.clientHeight;
      perspCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 10000);
      perspCamera.up.set(0, 0, 1);  // Z is up
      perspCamera.position.set(100, 100, 100);

      // Orthographic camera (size will be adjusted when model loads)
      const frustumSize = 100;
      orthoCamera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2, frustumSize * aspect / 2,
        frustumSize / 2, -frustumSize / 2,
        0.1, 10000
      );
      orthoCamera.up.set(0, 0, 1);
      orthoCamera.position.set(100, 100, 100);

      camera = perspCamera;  // Start with perspective

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      // Controls - TrackballControls uses quaternions, eliminating gimbal lock
      controls = new TrackballControls(camera, renderer.domElement);
      controls.rotateSpeed = 2.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.8;
      controls.staticMoving = true;  // No inertia for precise control
      controls.dynamicDampingFactor = 0.3;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);

      const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight1.position.set(1, 1, 1);
      scene.add(directionalLight1);

      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight2.position.set(-1, -1, -1);
      scene.add(directionalLight2);

      // Grid on XY plane (Z=0) for Z-up coordinate system
      // 260mm with 26 divisions (27 lines) - roughly print bed size, 10mm squares
      gridHelper = new THREE.GridHelper(260, 26, 0x808080, 0x808080);
      gridHelper.rotation.x = Math.PI / 2;  // Rotate from XZ to XY plane
      gridHelper.material.transparent = true;
      gridHelper.material.opacity = 0.5;
      scene.add(gridHelper);

      // Axes helper at origin
      axesHelper = new THREE.AxesHelper(50);
      scene.add(axesHelper);

      // Load model based on format
      loadModel();

      // Event listeners
      window.addEventListener('resize', onResize);

      // Control buttons
      resetBtn.addEventListener('click', fitToView);
      wireframeBtn.addEventListener('click', toggleWireframe);
      axesBtn.addEventListener('click', toggleAxes);
      gridBtn.addEventListener('click', toggleGrid);

      // View buttons (Z-up coordinate system: X=right, Y=front, Z=up)
      viewTop.addEventListener('click', () => setView(0, 0, 1));     // Looking down from +Z
      viewBottom.addEventListener('click', () => setView(0, 0, -1)); // Looking up from -Z
      viewFront.addEventListener('click', () => setView(0, -1, 0));  // Looking from -Y
      viewBack.addEventListener('click', () => setView(0, 1, 0));    // Looking from +Y
      viewRight.addEventListener('click', () => setView(1, 0, 0));   // Looking from +X (right side)
      viewLeft.addEventListener('click', () => setView(-1, 0, 0));   // Looking from -X (left side)
      viewIso.addEventListener('click', toggleOrthographic);         // Toggle perspective/orthographic

      // Animation loop
      animate();
    }

    function loadModel() {
      loadingText.textContent = `Loading ${FORMAT.toUpperCase()} model...`;

      if (FORMAT === '3mf') {
        load3MF();
      } else {
        loadSTL();
      }
    }

    function loadSTL() {
      const loader = new STLLoader();

      loader.load(
        'api/model',
        (geometry) => {
          // Center geometry in XY, keep Z base at 0
          geometry.computeBoundingBox();
          const center = new THREE.Vector3();
          geometry.boundingBox.getCenter(center);
          geometry.translate(-center.x, -center.y, -center.z);

          // Move to sit on grid (Z=0 plane)
          const minZ = geometry.boundingBox.min.z - center.z;
          geometry.translate(0, 0, -minZ);

          // Recalculate bounding box after translation
          geometry.computeBoundingBox();

          // Material
          const material = new THREE.MeshPhongMaterial({
            color: 0x3b82f6,
            specular: 0x111111,
            shininess: 30,
            flatShading: false
          });

          model = new THREE.Mesh(geometry, material);
          scene.add(model);

          setupAfterLoad(model);

          // Update info
          const triangles = geometry.attributes.position.count / 3;
          info.textContent = ` - ${triangles.toLocaleString()} triangles`;
        },
        undefined,
        (err) => {
          showError('Failed to load STL file: ' + (err.message || 'Unknown error'));
        }
      );
    }

    function load3MF() {
      const loader = new ThreeMFLoader();

      loader.load(
        'api/model',
        (group) => {
          // 3MFLoader returns a Group with meshes
          // 3MF uses Z-up natively, which matches our coordinate system
          // Keep model at original position (don't center) to preserve coordinate alignment

          model = group;
          scene.add(model);

          setupAfterLoad(model);

          // Count triangles and objects
          let triangleCount = 0;
          let objectCount = 0;
          group.traverse((child) => {
            if (child.isMesh) {
              objectCount++;
              const geom = child.geometry;
              if (geom.index) {
                triangleCount += geom.index.count / 3;
              } else if (geom.attributes.position) {
                triangleCount += geom.attributes.position.count / 3;
              }
            }
          });

          info.textContent = ` - ${triangleCount.toLocaleString()} triangles, ${objectCount} object${objectCount !== 1 ? 's' : ''}`;
        },
        undefined,
        (err) => {
          showError('Failed to load 3MF file: ' + (err.message || 'Unknown error'));
        }
      );
    }

    function setupAfterLoad(object) {
      // Calculate model center and size
      const box = new THREE.Box3().setFromObject(object);
      box.getCenter(modelCenter);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      cameraDistance = maxDim * 2;

      // Configure orthographic camera frustum based on model size
      const aspect = container.clientWidth / container.clientHeight;
      const frustumSize = maxDim * 1.5;
      orthoCamera.left = -frustumSize * aspect / 2;
      orthoCamera.right = frustumSize * aspect / 2;
      orthoCamera.top = frustumSize / 2;
      orthoCamera.bottom = -frustumSize / 2;
      orthoCamera.updateProjectionMatrix();

      // Grid: 260mm with 26 divisions (27 lines) - roughly print bed size, 10mm squares
      const gridSize = 260;
      const divisions = 26;  // 27 grid lines, 10mm per square
      scene.remove(gridHelper);
      gridHelper = new THREE.GridHelper(gridSize, divisions, 0x808080, 0x808080);
      gridHelper.rotation.x = Math.PI / 2;  // Rotate from XZ to XY plane
      gridHelper.material.transparent = true;
      gridHelper.material.opacity = 0.5;
      gridHelper.visible = showGrid;
      scene.add(gridHelper);

      scene.remove(axesHelper);
      axesHelper = new THREE.AxesHelper(gridSize / 2);
      axesHelper.visible = showAxes;
      scene.add(axesHelper);

      // Set camera to look at model center, default isometric view
      controls.target.copy(modelCenter);
      setView(1, -1, 0.8);  // Isometric-ish: see X going right, Y going back, Z going up

      // Hide loading
      loading.classList.add('hidden');
    }

    function showError(message) {
      console.error('Error:', message);
      loading.classList.add('hidden');
      error.style.display = 'block';
      errorMessage.textContent = message;
    }

    function fitToView() {
      if (!model) return;

      const box = new THREE.Box3().setFromObject(model);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = perspCamera.fov * (Math.PI / 180);
      cameraDistance = maxDim / (2 * Math.tan(fov / 2)) * 1.5;

      // Update orthographic frustum
      const aspect = container.clientWidth / container.clientHeight;
      const frustumSize = maxDim * 1.5;
      orthoCamera.left = -frustumSize * aspect / 2;
      orthoCamera.right = frustumSize * aspect / 2;
      orthoCamera.top = frustumSize / 2;
      orthoCamera.bottom = -frustumSize / 2;
      orthoCamera.updateProjectionMatrix();

      // Keep current view direction, just adjust distance
      const currentDir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      camera.position.copy(center).add(currentDir.multiplyScalar(cameraDistance));
      controls.target.copy(center);
      controls.update();
    }

    function toggleOrthographic() {
      isOrthographic = !isOrthographic;

      // Copy position and orientation from current camera to the other
      const newCamera = isOrthographic ? orthoCamera : perspCamera;
      newCamera.position.copy(camera.position);
      newCamera.up.copy(camera.up);
      newCamera.lookAt(controls.target);

      camera = newCamera;

      // Update controls to use new camera
      controls.object = camera;
      controls.update();

      // Update button state
      viewIso.classList.toggle('active', isOrthographic);
      viewIso.textContent = isOrthographic ? 'Ortho' : 'Persp';
    }

    function setView(x, y, z) {
      if (!model) return;

      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());

      // Normalize direction
      const dir = new THREE.Vector3(x, y, z).normalize();

      // Set camera position
      camera.position.copy(center).add(dir.multiplyScalar(cameraDistance));

      // Set up vector (Z-up coordinate system)
      // When looking straight up/down along Z, use Y as up reference
      if (Math.abs(z) > 0.9) {
        camera.up.set(0, z > 0 ? 1 : -1, 0);
      } else {
        camera.up.set(0, 0, 1);
      }

      // Look at center
      controls.target.copy(center);
      camera.lookAt(center);
      controls.update();
    }

    function toggleWireframe() {
      // Cycle through modes: solid -> wireframe -> both -> solid
      if (viewMode === 'solid') {
        viewMode = 'wireframe';
      } else if (viewMode === 'wireframe') {
        viewMode = 'both';
      } else {
        viewMode = 'solid';
      }
      applyViewMode();
    }

    function applyViewMode() {
      if (!model) return;

      // Remove existing wireframe overlay if any
      if (wireframeMesh) {
        scene.remove(wireframeMesh);
        wireframeMesh.traverse((child) => {
          if (child.isMesh) {
            child.geometry.dispose();
            child.material.dispose();
          }
        });
        wireframeMesh = null;
      }

      if (viewMode === 'solid') {
        // Solid mode: no wireframe
        model.traverse((child) => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.wireframe = false);
            } else {
              child.material.wireframe = false;
            }
          }
        });
        wireframeBtn.textContent = 'Wire';
        wireframeBtn.classList.remove('active');
      } else if (viewMode === 'wireframe') {
        // Wireframe only mode
        model.traverse((child) => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.wireframe = true);
            } else {
              child.material.wireframe = true;
            }
          }
        });
        wireframeBtn.textContent = 'Wire';
        wireframeBtn.classList.add('active');
      } else {
        // Both mode: solid + black wireframe overlay
        model.traverse((child) => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.wireframe = false);
            } else {
              child.material.wireframe = false;
            }
          }
        });
        // Create wireframe overlay
        wireframeMesh = createWireframeOverlay(model);
        if (wireframeMesh) {
          scene.add(wireframeMesh);
        }
        wireframeBtn.textContent = 'Both';
        wireframeBtn.classList.add('active');
      }
    }

    function createWireframeOverlay(sourceModel) {
      // Create a group to hold wireframe meshes
      const wireframeGroup = new THREE.Group();
      wireframeGroup.position.copy(sourceModel.position);
      wireframeGroup.rotation.copy(sourceModel.rotation);
      wireframeGroup.scale.copy(sourceModel.scale);

      sourceModel.traverse((child) => {
        if (child.isMesh) {
          const wireGeom = child.geometry.clone();
          const wireMat = new THREE.MeshBasicMaterial({
            color: 0x000000,
            wireframe: true,
            transparent: true,
            opacity: 0.3
          });
          const wireMesh = new THREE.Mesh(wireGeom, wireMat);
          wireMesh.position.copy(child.position);
          wireMesh.rotation.copy(child.rotation);
          wireMesh.scale.copy(child.scale);
          // Slight offset to prevent z-fighting
          wireMesh.renderOrder = 1;
          wireframeGroup.add(wireMesh);
        }
      });

      return wireframeGroup;
    }

    function toggleAxes() {
      showAxes = !showAxes;
      axesHelper.visible = showAxes;
      axesBtn.classList.toggle('active', showAxes);
      document.getElementById('axes-legend').style.display = showAxes ? 'block' : 'none';
    }

    function toggleGrid() {
      showGrid = !showGrid;
      gridHelper.visible = showGrid;
      gridBtn.classList.toggle('active', showGrid);
    }

    function onResize() {
      const aspect = container.clientWidth / container.clientHeight;

      // Update perspective camera
      perspCamera.aspect = aspect;
      perspCamera.updateProjectionMatrix();

      // Update orthographic camera (maintain frustum height, adjust width)
      const frustumHeight = orthoCamera.top - orthoCamera.bottom;
      orthoCamera.left = -frustumHeight * aspect / 2;
      orthoCamera.right = frustumHeight * aspect / 2;
      orthoCamera.updateProjectionMatrix();

      renderer.setSize(container.clientWidth, container.clientHeight);
      controls.handleResize();  // TrackballControls needs this to update screen dimensions
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Auto-reload: poll file mtime and reload model when changed
    let lastMtime = null;
    const POLL_INTERVAL = 1000; // 1 second

    async function checkForChanges() {
      try {
        const res = await fetch('api/mtime');
        if (res.ok) {
          const data = await res.json();
          if (lastMtime === null) {
            lastMtime = data.mtime;
          } else if (data.mtime !== lastMtime) {
            lastMtime = data.mtime;
            reloadModel();
          }
        }
      } catch (err) {
        // Ignore fetch errors (server may be restarting)
      }
    }

    function reloadModel() {
      // Remove old wireframe overlay
      if (wireframeMesh) {
        scene.remove(wireframeMesh);
        wireframeMesh.traverse((child) => {
          if (child.isMesh) {
            child.geometry.dispose();
            child.material.dispose();
          }
        });
        wireframeMesh = null;
      }

      // Remove old model
      if (model) {
        scene.remove(model);
        model.traverse((child) => {
          if (child.isMesh) {
            child.geometry.dispose();
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.dispose());
            } else if (child.material) {
              child.material.dispose();
            }
          }
        });
        model = null;
      }

      // Reload based on format
      if (FORMAT === '3mf') {
        reload3MF();
      } else {
        reloadSTL();
      }
    }

    function reloadSTL() {
      const loader = new STLLoader();
      loader.load('api/model?t=' + Date.now(), (geometry) => {
        // Center geometry in XY
        geometry.computeBoundingBox();
        const center = new THREE.Vector3();
        geometry.boundingBox.getCenter(center);
        geometry.translate(-center.x, -center.y, -center.z);

        // Move to sit on grid (Z=0 plane)
        const minZ = geometry.boundingBox.min.z - center.z;
        geometry.translate(0, 0, -minZ);

        // Recalculate bounding box after translation
        geometry.computeBoundingBox();

        // Create new material
        const material = new THREE.MeshPhongMaterial({
          color: 0x3b82f6,
          specular: 0x111111,
          shininess: 30,
          flatShading: false
        });

        model = new THREE.Mesh(geometry, material);
        scene.add(model);

        // Re-apply current view mode
        applyViewMode();

        // Update info
        const triangles = geometry.attributes.position.count / 3;
        info.textContent = ` - ${triangles.toLocaleString()} triangles (reloaded)`;

        // Brief flash to indicate reload
        setTimeout(() => {
          info.textContent = ` - ${triangles.toLocaleString()} triangles`;
        }, 1000);
      }, undefined, (err) => {
        console.error('Error reloading STL:', err);
      });
    }

    function reload3MF() {
      const loader = new ThreeMFLoader();
      loader.load('api/model?t=' + Date.now(), (group) => {
        // 3MF uses Z-up natively, which matches our coordinate system

        // Center the group in XY
        const box = new THREE.Box3().setFromObject(group);
        const center = box.getCenter(new THREE.Vector3());
        group.position.sub(center);

        // Move to sit on grid (Z=0 plane)
        const newBox = new THREE.Box3().setFromObject(group);
        group.position.z -= newBox.min.z;

        model = group;
        scene.add(model);

        // Re-apply current view mode
        applyViewMode();

        // Count triangles and objects
        let triangleCount = 0;
        let objectCount = 0;
        group.traverse((child) => {
          if (child.isMesh) {
            objectCount++;
            const geom = child.geometry;
            if (geom.index) {
              triangleCount += geom.index.count / 3;
            } else if (geom.attributes.position) {
              triangleCount += geom.attributes.position.count / 3;
            }
          }
        });

        info.textContent = ` - ${triangleCount.toLocaleString()} triangles, ${objectCount} object${objectCount !== 1 ? 's' : ''} (reloaded)`;

        setTimeout(() => {
          info.textContent = ` - ${triangleCount.toLocaleString()} triangles, ${objectCount} object${objectCount !== 1 ? 's' : ''}`;
        }, 1000);
      }, undefined, (err) => {
        console.error('Error reloading 3MF:', err);
      });
    }

    // Start polling for changes
    setInterval(checkForChanges, POLL_INTERVAL);

    // Start
    init();
  </script>
</body>
</html>
