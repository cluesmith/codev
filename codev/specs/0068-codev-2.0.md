# Specification: Codev 2.0 - CODEV_HQ + Deterministic Core

## Metadata
- **ID**: 0068
- **Status**: conceived
- **Created**: 2026-01-12
- **Protocol**: SPIR
- **Version Target**: v2.0.0

## Executive Summary

Codev 2.0 is a major platform rewrite addressing three fundamental limitations of v1.x:

1. **Fragile Terminal Layer**: ttyd + tmux is glued together, port-per-terminal, no stdout capture
2. **Local-Only Access**: Can't command agents from mobile or multiple devices
3. **Flaky Protocol Compliance**: SPIR phases rely on AI memory, not enforced by system

This spec defines a **CODEV_HQ** architecture with **Deterministic Core** that transforms Codev from a local scripting wrapper into a robust, multi-device development orchestration platform.

## Clarifying Questions Asked

**Q1: Should this be a full rewrite of Agent Farm as a VSCode extension?**
A1: No. VSCode Terminal API cannot capture stdout (critical limitation). Instead of IDE-specific extension, we're building **CODEV_HQ** - a cloud control plane accessible from any device including mobile.

**Q2: Should we use Temporal, Inngest, or custom SQLite for workflow enforcement?**
A2: **Status files (YAML frontmatter + Markdown)** - simplest approach that fits codev's existing patterns:
- **Git tracked**: Full audit trail, blame, history
- **Structured**: YAML frontmatter for gates (parseable), markdown body for logs
- **Human readable/editable**: Same pattern as projectlist.md
- **Claude native**: Already reads/writes this format
- **No infrastructure**: No database, no external server
See "Status File Approach" section below for details.

**Q3: Should mobile have full terminal access?**
A3: No. xterm.js has known mobile limitations (copy/paste, selection, predictive keyboard). Mobile should be **"Director's Chair"**: approve gates, view logs, send commands. Full terminal remains desktop/tablet only.

**Q4: Self-hosted vs SaaS vs hybrid?**
A4: **Hybrid ("Tethered Satellite")**: CODEV_HQ handles auth, coordination, dashboards. Local Runners handle execution, keeping code on user's machine. Optional managed runners for full SaaS.

## Problem Statement

### Current Architecture Limitations

**1. Terminal Layer (ttyd + tmux)**
```
Pain Points:
- Port sprawl: 100-port blocks per project
- No stdout capture: Can't observe builder output programmatically
- Fire-and-forget: tmux send-keys has no acknowledgment
- External dependencies: brew install ttyd tmux (platform friction)
```

**2. Dashboard (4,900 lines vanilla JS)**
```
Pain Points:
- No framework: DOM manipulation boilerplate
- No component reuse: Every feature is custom
- No type safety: Runtime errors in production
- Custom file browser: Reinventing wheels
```

**3. Protocol Enforcement (AI Honor System)**
```
Pain Points:
- Phases skipped: Claude forgets to consult
- Gates bypassed: Human approval not enforced
- Context loss: AI loses track mid-workflow
- No audit trail: Can't prove compliance
```

**4. Access Model (Localhost Only)**
```
Pain Points:
- Single device: Can't check status from phone
- No team access: Each developer runs separate instance
- No notifications: Must watch terminal for updates
```

## Desired State

### The Three Pillars of Codev 2.0

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           CODEV 2.0                                      │
├──────────────────────┬──────────────────────┬───────────────────────────┤
│   PILLAR 1           │   PILLAR 2           │   PILLAR 3                │
│   Terminal + UI      │   CODEV_HQ        │   Deterministic Core      │
│   Rewrite            │   + Mobile           │                           │
├──────────────────────┼──────────────────────┼───────────────────────────┤
│ • node-pty           │ • Cloud control      │ • State machine           │
│ • xterm.js           │   plane              │ • Phase gates             │
│ • WebSocket mux      │ • Local runners      │ • Artifact validation     │
│ • React + Vite       │ • Mobile PWA         │ • Human approval gates    │
│ • Single port        │ • Push notifications │ • Durable execution       │
│ • Stdout capture     │ • Team auth          │ • Context injection       │
└──────────────────────┴──────────────────────┴───────────────────────────┘
```

### Target Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         CLOUD TOWER                                      │
│                    (tower.codev.dev)                                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                  │
│  │   React PWA  │  │  Workflow    │  │  API/Auth    │                  │
│  │   Dashboard  │  │  Engine      │  │  (GraphQL)   │                  │
│  │   + Mobile   │  │  (Inngest)   │  │              │                  │
│  └──────────────┘  └──────────────┘  └──────────────┘                  │
│           │                │                │                           │
│           └────────────────┴────────────────┘                           │
│                            │                                            │
│                     WebSocket (WSS)                                     │
│                            │                                            │
└────────────────────────────┼────────────────────────────────────────────┘
                             │
         ┌───────────────────┴───────────────────┐
         │                                       │
         ▼                                       ▼
┌─────────────────────┐               ┌─────────────────────┐
│   LOCAL RUNNER      │               │   MANAGED RUNNER    │
│   (User's Machine)  │               │   (Codev Cloud)     │
│  ┌───────────────┐  │               │  ┌───────────────┐  │
│  │ Terminal Mgr  │  │               │  │ Terminal Mgr  │  │
│  │ (node-pty)    │  │               │  │ (node-pty)    │  │
│  └───────────────┘  │               │  └───────────────┘  │
│  ┌───────────────┐  │               │  ┌───────────────┐  │
│  │ State Machine │  │               │  │ State Machine │  │
│  │ (SQLite)      │  │               │  │ (SQLite)      │  │
│  └───────────────┘  │               │  └───────────────┘  │
│  ┌───────────────┐  │               │  ┌───────────────┐  │
│  │ Git Worktrees │  │               │  │ Git Worktrees │  │
│  └───────────────┘  │               │  └───────────────┘  │
└─────────────────────┘               └─────────────────────┘
```

## Stakeholders

- **Primary Users**: Developers using Codev for AI-assisted development
- **Secondary Users**: Teams wanting shared access, mobile users
- **Technical Team**: Codev maintainers
- **Business Owners**: Project owner (Waleed)

## Success Criteria

### Pillar 1: Terminal + UI Rewrite
- [ ] Single port handles all terminal sessions (no port sprawl)
- [ ] Stdout/stderr captured and accessible via API
- [ ] Dashboard rebuilt in React with Vite
- [ ] No required external dependencies (ttyd/tmux optional)
- [ ] <100ms terminal latency, <500ms dashboard load

### Pillar 2: CODEV_HQ + Mobile
- [ ] Users can access from multiple devices simultaneously
- [ ] Mobile PWA shows project status, logs, and approval gates
- [ ] Push notifications for blocked builders and required approvals
- [ ] Team authentication with role-based access
- [ ] Code stays on user's machine (local runner default)

### Pillar 3: Deterministic Core
- [ ] SPIR phases enforced by state machine, not AI memory
- [ ] Phase transitions require artifact validation (spec exists, plan approved)
- [ ] Human approval gates block AI progression
- [ ] AI context loss doesn't break workflow (state survives restart)
- [ ] Audit trail of all phase transitions and approvals

## Constraints

### Technical Constraints

**node-pty Platform Support:**
- Native module requires node-gyp compilation
- Pre-built binaries available for most platforms
- Fallback: Docker-based runner for problematic environments

**Mobile Terminal Limitations:**
- xterm.js on mobile has copy/paste, selection, keyboard issues
- Decision: Mobile is read-only logs + commands, not full terminal

**Workflow Engine Selection:**
- Local-only: SQLite state machine (no infrastructure)
- Cloud: Inngest (serverless-first) or Temporal (enterprise)
- Must support: gates, signals, retries, human-in-the-loop

### Business Constraints

- v1.x users must have migration path
- Local-only mode must remain viable (no forced cloud)
- CODEV_HQ can be self-hosted by enterprises

## Assumptions

- Users have Node.js 18+ (already required)
- Internet connectivity available for CODEV_HQ (but local mode works offline)
- React/TypeScript developers can maintain the codebase
- Inngest/Temporal can be self-hosted if needed

## Solution Approaches

### Pillar 1: Terminal + UI Rewrite

See **Spec 0067** for detailed approach. Summary:

| Current | Target |
|---------|--------|
| ttyd + tmux | node-pty + xterm.js |
| Port per terminal | WebSocket multiplexing |
| No stdout capture | Full capture via PTY |
| 4,900 lines vanilla JS | React + Vite + Tailwind |
| brew dependencies | Pure npm |

### Pillar 2: CODEV_HQ Architecture

**Recommended: "Tethered Satellite" / Hybrid Model**

```
┌──────────────────────────────────────────────────────┐
│ TOWER (Cloud)                                        │
│ • Authentication (Clerk/Auth0)                       │
│ • User/Team Management                               │
│ • Workflow State (Postgres + Inngest)                │
│ • Dashboard Serving (React PWA)                      │
│ • Notification Dispatch (Push, Email, Slack)         │
│ • WebSocket Relay                                    │
└────────────────────────┬─────────────────────────────┘
                         │ WSS (mTLS)
                         │
┌────────────────────────┴─────────────────────────────┐
│ RUNNER (Local or Managed)                            │
│ • Terminal Management (node-pty)                     │
│ • Local State (SQLite mirror)                        │
│ • Git Operations (worktrees, branches)               │
│ • Claude/LLM Invocation                              │
│ • Stdout Streaming to HQ                          │
└──────────────────────────────────────────────────────┘
```

**Why Hybrid:**
1. **Security**: Code never leaves user's machine (default)
2. **Cost**: Heavy compute on user's hardware, not our cloud
3. **Offline**: Local mode works without HQ
4. **Enterprise**: Self-host HQ behind VPN

**Mobile Experience ("Director's Chair"):**
- View project status and builder activity
- Approve/reject phase gates with one tap
- Read streaming logs (read-only)
- Send high-level commands ("run tests", "consult plan")
- Notifications for blocked builders
- NO full terminal (too painful on mobile)

### Pillar 3: Deterministic Core

**The Problem:**
```typescript
// v1.x: AI honor system
// Prompt says "consult GPT-5 and Gemini before proceeding"
// Claude sometimes forgets, sometimes skips
// No enforcement, no audit trail
```

**The Solution: Status Files (YAML + Markdown)**

Instead of databases or workflow engines, use git-tracked status files:
- `codev/status/{project}.md` with YAML frontmatter for structured gate data
- Markdown body for human-readable log
- Claude reads YAML at session start to know where it is
- Claude updates YAML as gates pass, appends to log
- Human approves by editing YAML (or via dashboard)
- Git provides full audit trail

See **Status File Approach** section below for details.

## Status File Approach

**Date**: 2026-01-12

After evaluating workflow engines (Temporal, Inngest) and custom SQLite, the simplest approach emerged: **markdown status files checked into git**.

### Why Markdown Over Workflow Engines

| Factor | Temporal/Inngest | SQLite | Markdown Status |
|--------|------------------|--------|-----------------|
| **Infrastructure** | External server | Database file | None |
| **Human readable** | Dashboard only | Queries needed | Yes (just open file) |
| **Git tracked** | No | No | Yes (full history) |
| **Claude native** | Needs wrapper | Needs wrapper | Already reads/writes md |
| **Human editable** | API calls | SQL | Direct edit |
| **Fits codev** | New pattern | New pattern | Matches specs/plans/reviews |

### Status File Format

Location: `codev/status/{project-number}-{name}.md`

Uses YAML frontmatter for structured data + Markdown body for logs (same pattern as projectlist.md).

```markdown
---
id: "0068"
title: "Codev 2.0"
protocol: SPIR
current_phase: plan
started_at: 2026-01-12T14:00:00

phases:
  specify: { status: completed, completed_at: 2026-01-12T15:30:00 }
  plan: { status: in_progress, started_at: 2026-01-12T15:35:00 }
  implement: { status: pending }
  defend: { status: pending }
  evaluate: { status: pending }
  review: { status: pending }

gates:
  specify_to_plan:
    spec_exists: { status: passed, path: codev/specs/0068-codev-2.0.md }
    human_approval: { status: passed, by: waleed, at: 2026-01-12T15:30:00 }
    consult_gemini: { status: passed, at: 2026-01-12T14:45:00 }
    consult_codex: { status: passed, at: 2026-01-12T14:52:00 }
  plan_to_implement:
    plan_exists: { status: pending }
    human_approval: { status: pending }
    consult_gemini: { status: pending }
    consult_codex: { status: pending }
---

## Log

- 2026-01-12 14:00: Started specification
- 2026-01-12 14:45: Gemini consultation complete - RECOMMEND
- 2026-01-12 14:52: Codex consultation complete - RECOMMEND
- 2026-01-12 15:30: Spec approved by waleed
- 2026-01-12 15:35: Started planning phase
```

### How It Works

**1. Session Start**
Claude reads the status file's YAML frontmatter:
```yaml
current_phase: plan
gates:
  plan_to_implement:
    plan_exists: { status: pending }  # ← blocks progress
```

**2. Progress Tracking**
Claude updates YAML as work completes and appends to log:
```yaml
consult_gemini: { status: passed, at: 2026-01-12T16:00:00 }
```

**3. Human Approval**
Human (or dashboard) edits the YAML:
```yaml
human_approval: { status: passed, by: waleed, at: 2026-01-12T16:30:00 }
```

**4. Gate Enforcement**
Claude checks gates before phase transition:
```
Can I proceed to implement?
→ Parse YAML frontmatter
→ Check gates.plan_to_implement.*
→ All status: passed? → Proceed
→ Any status: pending? → Report blockers
```

### Advantages

1. **Git history** - `git log codev/status/0068-*.md` shows all transitions
2. **Git blame** - who approved what, when
3. **Portable** - clone repo, get full state
4. **No infrastructure** - just files
5. **Human override** - edit file to fix mistakes or force transitions
6. **Merge-friendly** - conflicts rare (single writer), resolvable if they happen

## HQ Network Protocol

**CODEV_HQ** is the cloud control plane that manages multiple local Agent Farm instances.

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                        CODEV_HQ                              │
│                   (hq.codev.dev)                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │  WebSocket  │  │   REST API  │  │   Dashboard/Mobile  │  │
│  │   Server    │  │   /api/v1   │  │   (React PWA)       │  │
│  └──────┬──────┘  └──────┬──────┘  └──────────┬──────────┘  │
│         │                │                     │             │
│         └────────────────┴─────────────────────┘             │
│                          │                                   │
│                    ┌─────┴─────┐                            │
│                    │  Postgres │  (sessions, users, audit)  │
│                    └───────────┘                            │
└─────────────────────────────────────────────────────────────┘
                           │
              WebSocket (wss://)
              + API Key Auth
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
┌───────────────┐  ┌───────────────┐  ┌───────────────┐
│  Agent Farm   │  │  Agent Farm   │  │  Agent Farm   │
│  (laptop)     │  │  (desktop)    │  │  (server)     │
│               │  │               │  │               │
│ CODEV_HQ_URL  │  │ CODEV_HQ_URL  │  │ CODEV_HQ_URL  │
│ CODEV_HQ_KEY  │  │ CODEV_HQ_KEY  │  │ CODEV_HQ_KEY  │
└───────────────┘  └───────────────┘  └───────────────┘
```

### Environment Variables

```bash
# Required for HQ connection
export CODEV_HQ_URL="wss://hq.codev.dev/ws"
export CODEV_HQ_API_KEY="ck_live_abc123..."

# Optional
export CODEV_HQ_INSTANCE_NAME="waleed-macbook"  # Human-readable name
export CODEV_HQ_RECONNECT_DELAY=5000            # ms, default 5s
```

### Connection Lifecycle

**1. Initial Connection**
```
Agent Farm                              HQ
    │                                    │
    │──── WebSocket CONNECT ────────────►│
    │     Headers:                       │
    │       Authorization: Bearer <key>  │
    │       X-Instance-ID: <uuid>        │
    │       X-Instance-Name: <name>      │
    │                                    │
    │◄─── 101 Switching Protocols ───────│
    │                                    │
    │──── register ─────────────────────►│
    │     { projects: [...], status }    │
    │                                    │
    │◄─── registered ────────────────────│
    │     { session_id, server_time }    │
    │                                    │
```

**2. Heartbeat (every 30s)**
```
    │──── ping ─────────────────────────►│
    │     { ts: 1234567890 }             │
    │                                    │
    │◄─── pong ──────────────────────────│
    │     { ts: 1234567891 }             │
```

**3. Reconnection**
- On disconnect: exponential backoff (1s, 2s, 4s, 8s... max 60s)
- Include `X-Session-ID` header to resume session
- HQ buffers messages for 5 minutes for disconnected clients

### Message Envelope

All messages use JSON with this envelope:

```typescript
interface Message {
  type: string;           // Message type
  id: string;             // UUID for request/response correlation
  ts: number;             // Unix timestamp (ms)
  payload: object;        // Type-specific data
}

interface Response {
  type: string;           // Same as request type + "_response"
  id: string;             // Same ID as request (correlation)
  ts: number;
  success: boolean;
  error?: string;         // If success=false
  payload?: object;
}
```

### Message Types: Local → HQ

**register** - Initial registration after connect
```typescript
{
  type: "register",
  payload: {
    instance_id: "uuid",
    instance_name: "waleed-macbook",
    version: "2.0.0",
    projects: [
      {
        path: "/Users/waleed/dev/myproject",
        name: "myproject",
        git_remote: "github.com/waleed/myproject"
      }
    ]
  }
}
```

**status_update** - Project/builder status changed
```typescript
{
  type: "status_update",
  payload: {
    project_path: "/Users/waleed/dev/myproject",
    status_file: "codev/status/0068-codev-2.0.md",
    content: "---\nprotocol: SPIR\n...",  // Full YAML+MD content
    git_sha: "abc123"  // Commit SHA of status file
  }
}
```

**builder_update** - Builder spawned/status changed
```typescript
{
  type: "builder_update",
  payload: {
    project_path: "/Users/waleed/dev/myproject",
    builder_id: "0068",
    status: "implementing",  // spawning|implementing|blocked|pr-ready|complete
    phase: "phase-1",
    branch: "builder/0068-codev-2.0"
  }
}
```

**terminal_output** - Streaming terminal output (optional, if enabled)
```typescript
{
  type: "terminal_output",
  payload: {
    session_type: "architect" | "builder",
    session_id: "0068",
    data: "base64-encoded-output",
    sequence: 12345  // For ordering
  }
}
```

**gate_completed** - A gate was passed locally
```typescript
{
  type: "gate_completed",
  payload: {
    project_path: "/Users/waleed/dev/myproject",
    project_id: "0068",
    gate: "specify_to_plan.consult_gemini",
    completed_by: "system",
    completed_at: "2026-01-12T14:45:00Z"
  }
}
```

### Message Types: HQ → Local

**command** - Execute a command locally
```typescript
{
  type: "command",
  payload: {
    project_path: "/Users/waleed/dev/myproject",
    command: "spawn_builder" | "send_message" | "run_consultation" | "sync_status",
    args: {
      // command-specific
    }
  }
}
```

**approval** - Human approved a gate (from mobile/dashboard)
```typescript
{
  type: "approval",
  payload: {
    project_path: "/Users/waleed/dev/myproject",
    project_id: "0068",
    gate: "specify_to_plan.human_approval",
    approved_by: "waleed",
    approved_at: "2026-01-12T15:30:00Z",
    comment: "Looks good, proceed"
  }
}
// Local Agent Farm updates status file and commits
```

**terminal_input** - User typing in HQ dashboard (optional)
```typescript
{
  type: "terminal_input",
  payload: {
    session_type: "architect" | "builder",
    session_id: "0068",
    data: "base64-encoded-input"
  }
}
```

**config_update** - Configuration changed in HQ
```typescript
{
  type: "config_update",
  payload: {
    settings: {
      terminal_streaming: true,
      notification_preferences: {...}
    }
  }
}
```

### Message Types: Bidirectional

**sync_request** / **sync_response** - Full state sync
```typescript
// Request (either direction)
{
  type: "sync_request",
  payload: {
    project_path: "/Users/waleed/dev/myproject",
    last_known_sha: "abc123"  // null for full sync
  }
}

// Response
{
  type: "sync_response",
  payload: {
    project_path: "/Users/waleed/dev/myproject",
    status_files: [
      { path: "codev/status/0068-*.md", content: "...", sha: "def456" }
    ],
    builders: [...],
    current_sha: "def456"
  }
}
```

### State Ownership

| State | Owner | Sync Direction |
|-------|-------|----------------|
| Status files (YAML+MD) | Local (git) | Local → HQ (read-only mirror) |
| Human approvals | HQ | HQ → Local (written to status file) |
| Builder status | Local | Local → HQ |
| Terminal output | Local | Local → HQ (streaming) |
| User preferences | HQ | HQ → Local |
| Audit log | HQ | Write-only from both |

### Conflict Resolution

**Status file conflicts:**
- HQ never writes status files directly
- HQ sends `approval` message → Local writes to file → Local commits → Local sends `status_update`
- If local file changed while approval in flight: Local re-reads, merges approval, commits

**Offline behavior:**
- Local continues working, accumulates status updates
- On reconnect: send all pending updates in order
- HQ buffers approvals for offline instances (5 min default, configurable)

### Security

**Authentication:**
- API key in `Authorization: Bearer <key>` header
- Keys scoped to user account
- Keys can be revoked in HQ dashboard

**Authorization:**
- Instance can only update projects it registered
- HQ validates project ownership via git remote matching
- Commands require matching project registration

**Transport:**
- TLS required (wss://)
- Certificate pinning optional for enterprise

**Rate Limiting:**
- 100 messages/second per instance
- 10 MB/minute terminal output per instance
- Exceeded → 429 response, backoff required

### Error Handling

```typescript
// Error response
{
  type: "error",
  id: "correlates-to-request",
  payload: {
    code: "AUTH_FAILED" | "RATE_LIMITED" | "INVALID_MESSAGE" | "PROJECT_NOT_FOUND",
    message: "Human readable error",
    retry_after?: 5000  // ms, for rate limiting
  }
}
```

### Example Flow: Mobile Approval

```
Mobile User          HQ                    Local Agent Farm
    │                 │                           │
    │─ Tap "Approve" ─►│                           │
    │                 │                           │
    │                 │─── approval ─────────────►│
    │                 │    { gate: "human_...",   │
    │                 │      approved_by: "..." } │
    │                 │                           │
    │                 │                     Update status file
    │                 │                     git add + commit
    │                 │                           │
    │                 │◄── status_update ─────────│
    │                 │    { content: "...",      │
    │                 │      git_sha: "..." }     │
    │                 │                           │
    │◄─ UI Update ────│                           │
    │  "Gate passed"  │                           │
```

## Open Questions

### Critical (Blocks Progress)
- [x] VSCode extension vs CODEV_HQ? **Answer: CODEV_HQ**
- [x] Temporal vs Inngest vs SQLite vs Markdown? **Answer: YAML frontmatter + Markdown (like projectlist.md)**
- [x] Mobile full terminal? **Answer: No, Director's Chair only**

### Important (Affects Design)
- [ ] Should HQ be multi-tenant SaaS or single-tenant self-host?
- [ ] What authentication provider? (Clerk, Auth0, custom)
- [x] How to handle offline → online sync? **Answer: Local continues, buffers updates, sends on reconnect**
- [x] WebSocket vs gRPC for HQ ↔ Local communication? **Answer: WebSocket (simpler, browser-compatible)**

### Nice-to-Know (Optimization)
- [ ] Can we use WebRTC for peer-to-peer terminal streaming?
- [ ] Is there value in AI-powered log summarization for mobile?

## Performance Requirements

- **Terminal Latency**: <100ms round-trip for keystrokes
- **Dashboard Load**: <500ms first contentful paint
- **Mobile PWA**: <3s time-to-interactive on 3G
- **API Response**: <50ms for state queries
- **HQ ↔ Runner**: <200ms WebSocket round-trip
- **Notification Delivery**: <5s for push notifications

## Security Considerations

- **Local Runner Default**: Code stays on user's machine
- **mTLS for Runner ↔ HQ**: Mutual authentication
- **Short-lived Tokens**: Runner tokens rotate per session
- **Audit Trail**: All phase transitions logged with actor
- **Optional Encryption**: Customer-managed keys for stdout archives
- **IP Allowlists**: Enterprise feature for HQ access

## Test Scenarios

### Functional Tests
1. **Happy Path**: Start project → Complete SPIR phases → Review
2. **Gate Enforcement**: AI tries to skip consultation → System blocks
3. **Human Approval**: Spec created → Mobile notification → Approve from phone → AI continues
4. **Context Recovery**: AI crashes mid-phase → Restart → Resumes from exact state
5. **Multi-device**: Start on laptop → Check status on phone → Continue on laptop

### Non-Functional Tests
1. **Latency**: Measure terminal round-trip under load
2. **Offline**: Disconnect HQ → Local continues → Reconnect → Sync
3. **Scale**: 50 concurrent builders, 10 projects, 5 devices

## Dependencies

- **External Services**: Auth provider (for CODEV_HQ)
- **Internal Systems**: Git (status files), git worktrees, Claude CLI
- **Libraries/Frameworks**:
  - `node-pty` - Pseudo-terminal spawning
  - `xterm.js` - Browser terminal emulator
  - `react` + `vite` - Dashboard framework
  - `ws` - WebSocket server

## References

- [Spec 0067: Agent Farm Architecture Rewrite](./0067-agent-farm-architecture-rewrite.md) - Pillar 1 details
- [Temporal for AI](https://temporal.io/solutions/ai) - Durable execution patterns
- [Inngest Documentation](https://www.inngest.com/docs) - Serverless workflow engine
- [xterm.js Mobile Issues](https://github.com/xtermjs/xterm.js/issues/5377) - Touch support limitations

## Risks and Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|------------|--------|---------------------|
| node-pty compilation issues | Medium | High | Provide Docker runner, prebuilt binaries |
| Inngest vendor lock-in | Low | Medium | Abstract workflow layer, Temporal as fallback |
| Mobile PWA adoption | Medium | Low | Start with web, native apps later if needed |
| CODEV_HQ cost growth | Medium | Medium | Keep compute on local runners, charge for managed |
| Migration friction from v1.x | Medium | Medium | Feature flags, parallel modes during transition |

## Expert Consultation

**Date**: 2026-01-12
**Models Consulted**: Gemini 3 Pro, GPT-5 Codex

### Gemini (RECOMMEND "Tethered Satellite")
- CODEV_HQ as lightweight control plane, Local Agent as execution
- SQLite state machine for deterministic core (simpler than Temporal)
- Mobile as "Director's Chair" - read/approve/command, no terminal
- "Do not try to host the user's development environment in your cloud initially"

### Codex (RECOMMEND "Gitpod-style Hybrid")
- HQ handles auth, coordination, dashboards, notification fan-out
- Runners execute locally or in customer VPC
- Temporal for workflow enforcement (stronger than SQLite)
- Mobile PWA focused on command + status, not terminal
- "SPIR compliance an enforced reality rather than an honor system"

### Consensus
Both models strongly recommend:
1. **Hybrid architecture**: Cloud control plane + local/pluggable execution
2. **Mobile limitations**: Don't ship full terminal on phone
3. **Deterministic enforcement**: State machine, not AI memory
4. **Incremental migration**: Local-only first, then add CODEV_HQ

### User Input
- Consider **Inngest** over Temporal (serverless-first, simpler)
- Focus on mobile command/status for "commanding agents from phone"

## Approval

- [ ] Technical Lead Review
- [ ] Product Owner Review
- [ ] Stakeholder Sign-off
- [x] Expert AI Consultation Complete

## Notes

### Why Codev 2.0?

Codev v1.x proved the concept: AI agents can execute structured development protocols, parallel builders accelerate delivery, and observability via dashboard provides control. But the implementation was bootstrapped:

- **ttyd + tmux**: Pragmatic but fragile
- **Vanilla JS dashboard**: Fast to build, hard to maintain
- **AI-enforced protocol**: Works until Claude forgets

Version 2.0 graduates from "it works" to "it's robust." The three pillars address root causes, not symptoms:

1. **Terminal rewrite**: First-party control, no external dependencies
2. **CODEV_HQ**: Multi-device by design, not afterthought
3. **Deterministic core**: System enforces, AI executes

### Relationship to Spec 0066 and 0067

- **0066 (VSCode Extension)**: ABANDONED - CODEV_HQ + Mobile PWA is more universal
- **0067 (Architecture Rewrite)**: SUBSUMED - Becomes Pillar 1 of this spec

### Migration Path

1. **v1.6.x → v1.9.x**: Feature flags for new terminal layer, local state machine
2. **v1.9.x → v2.0.0-alpha**: CODEV_HQ opt-in, mobile PWA preview
3. **v2.0.0**: Full release with both local and cloud modes

Local-only users can stay on local mode indefinitely. CODEV_HQ is additive, not replacement.

---

## Amendments

This section tracks all TICK amendments to this specification.

<!-- When adding a TICK amendment, add a new entry below this line in chronological order -->
